<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Chord Namer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root {
    color-scheme: light;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    background: #f4f6fb;
    color: #1d1d1f;
  }

  a {
    color: inherit;
  }

  .app {
    max-width: 1080px;
    margin: 0 auto;
    padding: 48px 24px 64px;
  }

  header {
    margin-bottom: 32px;
  }

  h1 {
    font-size: clamp(2rem, 4vw, 2.8rem);
    margin: 0 0 12px;
    color: #253062;
    letter-spacing: -0.02em;
  }

  .lead {
    margin: 0;
    max-width: 720px;
    color: #47506b;
    line-height: 1.6;
    font-size: 1.05rem;
  }

  .controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 24px;
  }

  .control-label {
    font-size: 0.95rem;
    color: #4b567a;
    margin-right: 8px;
  }

  .shape-pill {
    display: inline-block;
    background: #eef2ff;
    color: #253062;
    padding: 6px 12px;
    border-radius: 999px;
    font-weight: 600;
    letter-spacing: 0.04em;
  }

  .reset-button {
    background: #3b5bfd;
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 10px 16px;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, transform 0.15s ease;
  }

  .reset-button:hover,
  .reset-button:focus {
    background: #304ae6;
  }

  .reset-button:active {
    transform: translateY(1px);
  }

  .fretboard-wrapper {
    background: #fff;
    border-radius: 16px;
    box-shadow: 0 24px 65px rgba(45, 60, 140, 0.15);
    padding: 24px;
    overflow-x: auto;
    margin-bottom: 28px;
  }

  table.fretboard {
    width: 100%;
    border-collapse: collapse;
    min-width: 780px;
  }

  .fretboard thead th {
    font-size: 0.68rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: #6a759b;
    padding-bottom: 10px;
    font-weight: 600;
  }

  .fretboard tbody td {
    padding: 4px;
    text-align: center;
  }

  .mute-col {
    width: 85px;
  }

  .string-col {
    width: 110px;
  }

  .string-label-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-weight: 600;
    color: #1f2b59;
  }

  .string-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 999px;
    background: #e7ecff;
    font-size: 0.85rem;
    color: #2a3d83;
  }

  .string-note {
    font-size: 1rem;
    letter-spacing: 0.04em;
  }

  .fret-selector {
    display: block;
    position: relative;
    cursor: pointer;
  }

  .fret-selector-input {
    position: absolute;
    opacity: 0;
    pointer-events: none;
  }

  .fret-selector-label {
    display: block;
    padding: 8px 0;
    border-radius: 8px;
    border: 1px solid transparent;
    transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    font-size: 0.95rem;
  }

  .fret-selector-input:focus + .fret-selector-label {
    border-color: rgba(59, 91, 253, 0.35);
    box-shadow: 0 0 0 3px rgba(59, 91, 253, 0.25);
  }

  .fret-selector-input:checked + .fret-selector-label {
    background: #3b5bfd;
    color: #fff;
    font-weight: 600;
    box-shadow: 0 12px 24px rgba(59, 91, 253, 0.28);
  }

  .fret-selector-label:hover {
    background: rgba(59, 91, 253, 0.08);
  }

  .insight-card {
    background: #fff;
    border-radius: 16px;
    box-shadow: 0 22px 60px rgba(31, 46, 95, 0.12);
    padding: 28px;
    margin-bottom: 28px;
  }

  .bulk-card {
    background: #fff;
    border-radius: 16px;
    box-shadow: 0 22px 60px rgba(31, 46, 95, 0.12);
    padding: 20px 24px;
    margin-bottom: 28px;
  }

  .rows-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px;
  }

  .six-row-list {
    display: grid;
    gap: 10px;
  }

  .six-input-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .cell-input {
    width: 3.2ch;
    text-align: center;
    padding: 6px 6px;
    border-radius: 8px;
    border: 1px solid #c9d1ff;
    font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 0.95rem;
    text-transform: uppercase;
  }

  .cell-input.error {
    border-color: #b3261e;
    background: #fdecea;
  }

  .row-meta {
    display: flex;
    align-items: center;
    gap: 10px;
    color: #4b567a;
    font-size: 0.9rem;
  }

  .bulk-input {
    width: 100%;
    min-height: 120px;
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid #c9d1ff;
    font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 0.95rem;
    resize: vertical;
  }

  .bulk-hint {
    font-size: 0.9rem;
    color: #4b567a;
    margin-top: 6px;
  }

  .small-button {
    background: #3b5bfd;
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
  }

  .parsed-suggest {
    font-size: 0.9rem;
    color: #4b567a;
  }

  .insight-card h2 {
    margin: 0 0 12px;
    color: #23336e;
    font-size: 1.35rem;
  }

  .insight-card p {
    margin: 0 0 16px;
    color: #4c567a;
    line-height: 1.6;
  }

  .note-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 12px 0 16px;
  }

  .note-tag {
    background: #eef2ff;
    color: #253062;
    padding: 6px 12px;
    border-radius: 999px;
    font-weight: 600;
    letter-spacing: 0.04em;
  }

  .note-breakdown {
    list-style: none;
    margin: 0;
    padding: 0;
    display: grid;
    gap: 6px;
  }

  .note-breakdown li {
    font-size: 0.95rem;
    color: #434e73;
  }

  .note-strong {
    font-weight: 600;
    color: #253062;
  }

  .chord-list {
    list-style: none;
    padding: 0;
    margin: 20px 0 0;
    display: grid;
    gap: 12px;
  }

  .chord-item {
    background: #f6f7ff;
    border: 1px solid #dfe4ff;
    border-radius: 14px;
    padding: 18px 20px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .chord-name {
    font-weight: 700;
    font-size: 1.2rem;
    color: #253062;
  }

  .chord-details {
    font-size: 0.95rem;
    color: #4b567a;
  }

  .chord-formula {
    font-size: 0.85rem;
    color: #5c6aad;
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }

  @media (max-width: 720px) {
    .controls {
      flex-direction: column;
      align-items: flex-start;
    }

    .fretboard-wrapper {
      padding: 18px;
    }

    table.fretboard {
      min-width: 640px;
    }

    .insight-card {
      padding: 22px;
    }

    .six-input-row {
      gap: 6px;
    }
  }
</style>
</head>
<body>
<div id="root"></div>
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
<script type="text/babel">
  const STANDARD_TUNING = [
    { name: 'E', midi: 40 },
    { name: 'A', midi: 45 },
    { name: 'D', midi: 50 },
    { name: 'G', midi: 55 },
    { name: 'B', midi: 59 },
    { name: 'E', midi: 64 },
  ];

  const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

  const NOTE_INDEX = NOTE_NAMES.reduce((map, note, index) => {
    map[note] = index;
    return map;
  }, {});

  const FRETS = Array.from({ length: 37 }, (_, index) => index); // 0â€“36

  const DEFAULT_POSITIONS = ['x', 3, 2, 0, 1, 0]; // C major open shape

  const CHORD_PATTERNS = [
    { id: 'maj', intervals: [0, 4, 7], description: 'Major triad', formula: '1 3 5', buildName: (root) => root },
    { id: 'min', intervals: [0, 3, 7], description: 'Minor triad', formula: '1 b3 5', buildName: (root) => root + 'm' },
    { id: 'sus2', intervals: [0, 2, 7], description: 'Suspended second', formula: '1 2 5', buildName: (root) => root + 'sus2' },
    { id: 'sus4', intervals: [0, 5, 7], description: 'Suspended fourth', formula: '1 4 5', buildName: (root) => root + 'sus4' },
    { id: 'dim', intervals: [0, 3, 6], description: 'Diminished triad', formula: '1 b3 b5', buildName: (root) => root + 'dim' },
    { id: 'aug', intervals: [0, 4, 8], description: 'Augmented triad', formula: '1 3 #5', buildName: (root) => root + 'aug' },
    { id: 'maj6', intervals: [0, 4, 7, 9], description: 'Major sixth', formula: '1 3 5 6', buildName: (root) => root + '6' },
    { id: 'min6', intervals: [0, 3, 7, 9], description: 'Minor sixth', formula: '1 b3 5 6', buildName: (root) => root + 'm6' },
    { id: 'maj7', intervals: [0, 4, 7, 11], description: 'Major seventh', formula: '1 3 5 7', buildName: (root) => root + 'maj7' },
    { id: 'min7', intervals: [0, 3, 7, 10], description: 'Minor seventh', formula: '1 b3 5 b7', buildName: (root) => root + 'm7' },
    { id: 'dom7', intervals: [0, 4, 7, 10], description: 'Dominant seventh', formula: '1 3 5 b7', buildName: (root) => root + '7' },
    { id: 'm7b5', intervals: [0, 3, 6, 10], description: 'Half-diminished', formula: '1 b3 b5 b7', buildName: (root) => root + 'm7b5' },
    { id: 'dim7', intervals: [0, 3, 6, 9], description: 'Diminished seventh', formula: '1 b3 b5 bb7', buildName: (root) => root + 'dim7' },
    { id: 'add9', intervals: [0, 2, 4, 7], description: 'Add nine', formula: '1 3 5 9', buildName: (root) => root + 'add9' },
    { id: 'madd9', intervals: [0, 2, 3, 7], description: 'Minor add nine', formula: '1 b3 5 9', buildName: (root) => root + 'madd9' },
    { id: 'maj9', intervals: [0, 2, 4, 7, 11], description: 'Major ninth', formula: '1 3 5 7 9', buildName: (root) => root + 'maj9' },
    { id: 'dom9', intervals: [0, 2, 4, 7, 10], description: 'Dominant ninth', formula: '1 3 5 b7 9', buildName: (root) => root + '9' },
    { id: 'min9', intervals: [0, 2, 3, 7, 10], description: 'Minor ninth', formula: '1 b3 5 b7 9', buildName: (root) => root + 'm9' },
  ];

  function formatShape(positions) {
    return '{' + positions.map((pos) => (pos === 'x' ? 'X' : pos)).join(' ') + '}';
  }

  function wrapModulo(n, mod) {
    return ((n % mod) + mod) % mod;
  }

  function getTransposedTuning(semitones) {
    return STANDARD_TUNING.map((t) => {
      const idx = wrapModulo(NOTE_INDEX[t.name] + semitones, NOTE_NAMES.length);
      return { name: NOTE_NAMES[idx], midi: t.midi + semitones };
    });
  }

  function analyzePositions(positions, tuning) {
    const playedNotes = [];
    const seenNotes = new Set();
    const uniqueNotes = [];

    positions.forEach((fret, stringIdx) => {
      if (fret === 'x') {
        return;
      }

      const stringTuning = tuning[stringIdx];
      const noteIndex = (NOTE_INDEX[stringTuning.name] + fret) % NOTE_NAMES.length;
      const note = NOTE_NAMES[noteIndex];
      const pitch = stringTuning.midi + fret;

      const noteInfo = {
        string: stringIdx,
        fret,
        note,
        pitch,
      };

      playedNotes.push(noteInfo);

      if (!seenNotes.has(note)) {
        seenNotes.add(note);
        uniqueNotes.push(note);
      }
    });

    const bass = playedNotes.reduce((lowest, current) => {
      if (!lowest || current.pitch < lowest.pitch) {
        return current;
      }
      return lowest;
    }, null);

    return {
      playedNotes,
      uniqueNotes,
      bassNote: bass ? bass.note : null,
    };
  }

  function intervalsFromRoot(notes, root) {
    const rootIndex = NOTE_INDEX[root];
    const intervals = new Set();

    notes.forEach((note) => {
      const noteIndex = NOTE_INDEX[note];
      const interval = (noteIndex - rootIndex + NOTE_NAMES.length) % NOTE_NAMES.length;
      intervals.add(interval);
    });

    return Array.from(intervals).sort((a, b) => a - b);
  }

  function isExactMatch(candidate, pattern) {
    if (candidate.length !== pattern.length) {
      return false;
    }
    for (let i = 0; i < pattern.length; i += 1) {
      if (candidate[i] !== pattern[i]) {
        return false;
      }
    }
    return true;
  }

  function dedupeMatches(matches) {
    const seen = new Set();
    return matches.filter((match) => {
      if (seen.has(match.displayName)) {
        return false;
      }
      seen.add(match.displayName);
      return true;
    });
  }

  function computeChordSuggestions(notes, bassNote) {
    if (notes.length < 2) {
      return [];
    }

    const matches = [];

    notes.forEach((root) => {
      const intervals = intervalsFromRoot(notes, root);

      CHORD_PATTERNS.forEach((pattern) => {
        if (isExactMatch(intervals, pattern.intervals)) {
          const baseName = pattern.buildName(root);
          const displayName = bassNote && bassNote !== root ? baseName + '/' + bassNote : baseName;
          matches.push({
            id: pattern.id + '-' + root + '-' + displayName,
            displayName,
            description: pattern.description,
            formula: pattern.formula,
          });
        }
      });
    });

    return dedupeMatches(matches);
  }

  function StringRow({ stringIdx, selection, onChange, tuning }) {
    const stringNumber = tuning.length - stringIdx;
    const stringTuning = tuning[stringIdx];

    return (
      <tr>
        <td>
          <label className="fret-selector">
            <input
              className="fret-selector-input"
              type="radio"
              name={'string-' + stringIdx}
              value="x"
              checked={selection === 'x'}
              onChange={() => onChange('x')}
            />
            <span className="fret-selector-label">Mute</span>
          </label>
        </td>
        <td>
          <div className="string-label-cell">
            <span className="string-badge">{stringNumber}</span>
            <span className="string-note">{stringTuning.name}</span>
          </div>
        </td>
        {FRETS.map((fret) => (
          <td key={fret}>
            <label className="fret-selector">
              <input
                className="fret-selector-input"
                type="radio"
                name={'string-' + stringIdx}
                value={fret}
                checked={selection === fret}
                onChange={() => onChange(fret)}
              />
              <span className="fret-selector-label">{fret === 0 ? 'Open' : fret}</span>
            </label>
          </td>
        ))}
      </tr>
    );
  }

  function Fretboard({ positions, onChange, tuning }) {
    return (
      <div className="fretboard-wrapper">
        <table className="fretboard">
          <thead>
            <tr>
              <th className="mute-col">Mute</th>
              <th className="string-col">String</th>
              {FRETS.map((fret) => (
                <th key={fret}>{fret === 0 ? 'Open' : 'F' + fret}</th>
              ))}
            </tr>
          </thead>
          <tbody>
            {positions.map((selection, idx) => (
              <StringRow
                key={idx}
                stringIdx={idx}
                selection={selection}
                onChange={(value) => onChange(idx, value)}
                tuning={tuning}
              />
            ))}
          </tbody>
        </table>
      </div>
    );
  }

  function App() {
    const [positions, setPositions] = React.useState(DEFAULT_POSITIONS);
    const [transpose, setTranspose] = React.useState(0);
    const [bulkText, setBulkText] = React.useState('');
    const emptyRow = () => ['', '', '', '', '', ''];
    const [rows, setRows] = React.useState([emptyRow()]);

    const tuning = React.useMemo(() => getTransposedTuning(transpose), [transpose]);

    const handleFretChange = (stringIdx, value) => {
      setPositions((prev) => {
        const next = prev.slice();
        next[stringIdx] = value;
        return next;
      });
    };

    const resetPositions = () => {
      setPositions(DEFAULT_POSITIONS.slice());
    };

    const analysis = React.useMemo(() => analyzePositions(positions, tuning), [positions, tuning]);
    const chordSuggestions = React.useMemo(
      () => computeChordSuggestions(analysis.uniqueNotes, analysis.bassNote),
      [analysis.uniqueNotes, analysis.bassNote]
    );

    function parseLineToPositions(line) {
      let cleaned = line.trim();
      if (!cleaned) return { error: 'Empty line', positions: null };

      // Allow surrounding braces or brackets: {X 3 2 0 1 0}
      cleaned = cleaned.replace(/[{}()\[\]]/g, '').trim();

      // Compact style support (single chars only): x32010
      if (/^[xX0-9]{6}$/.test(cleaned)) {
        const arr = cleaned.toUpperCase().split('').map((ch) => (ch === 'X' ? 'x' : parseInt(ch, 10)));
        return { positions: arr, error: null };
      }

      // Accept delimiters: space, comma, semicolon, dash, slash, pipe
      const tokens = cleaned.split(/[\s,;\-|/]+/).filter(Boolean);
      if (tokens.length !== 6) {
        return { error: 'Expected 6 entries (got ' + tokens.length + ')', positions: null };
      }
      const pos = [];
      for (let i = 0; i < 6; i += 1) {
        const t = tokens[i].trim();
        if (/^[xX]$/.test(t)) {
          pos.push('x');
        } else if (/^\d+$/.test(t)) {
          const n = parseInt(t, 10);
          if (n < 0 || n > 24) {
            return { error: 'Fret out of range: ' + n + ' (0â€“24)', positions: null };
          }
          pos.push(n);
        } else {
          return { error: 'Invalid token: ' + t, positions: null };
        }
      }
      return { positions: pos, error: null };
    }

    function parseCellValue(v) {
      const t = (v || '').trim();
      if (t === '') return { ok: false, reason: 'empty' };
      if (/^[xX]$/.test(t)) return { ok: true, value: 'x' };
      if (/^\d+$/.test(t)) {
        const n = parseInt(t, 10);
        if (n < 0 || n > 24) return { ok: false, reason: 'range' };
        return { ok: true, value: n };
      }
      return { ok: false, reason: 'invalid' };
    }

    function parseRowCells(cells) {
      if (!cells || cells.length !== 6) return { error: 'Need 6 values', positions: null, errors: Array(6).fill('empty') };
      const pos = [];
      const errs = [];
      for (let i = 0; i < 6; i += 1) {
        const r = parseCellValue(cells[i]);
        if (!r.ok) {
          errs[i] = r.reason;
        } else {
          errs[i] = null;
          pos.push(r.value);
        }
      }
      const anyError = errs.some((e) => e);
      if (anyError) return { error: 'incomplete', positions: null, errors: errs };
      return { error: null, positions: pos, errors: errs };
    }

    const rowResults = React.useMemo(() => {
      return rows.map((cells, idx) => {
        const parsed = parseRowCells(cells);
        if (parsed.error || !parsed.positions) {
          return { id: 'row-' + idx, cells, parsed, analysis: null, suggestions: [] };
        }
        const a = analyzePositions(parsed.positions, tuning);
        const s = computeChordSuggestions(a.uniqueNotes, a.bassNote);
        return { id: 'row-' + idx, cells, parsed, analysis: a, suggestions: s };
      });
    }, [rows, tuning]);

    function updateCell(rowIdx, cellIdx, value) {
      setRows((prev) => {
        const next = prev.map((r) => r.slice());
        next[rowIdx][cellIdx] = value;
        return next;
      });
    }

    function addRow() {
      setRows((prev) => prev.concat([emptyRow()]));
    }

    function removeRow(rowIdx) {
      setRows((prev) => (prev.length <= 1 ? prev : prev.filter((_, i) => i !== rowIdx)));
    }

    return (
      <div className="app">
        <header>
          <h1>Chord Namer</h1>
          <p className="lead">
            Select frets across the guitar strings to discover matching chord names. The engine translates your voicing into theory-friendly labels.
          </p>
        </header>

        <div className="controls">
          <div>
            <span className="control-label">Current shape:</span>
            <code className="shape-pill">{formatShape(positions)}</code>
          </div>
          <div>
            <label className="control-label" htmlFor="transpose">Transpose:</label>
            <input
              id="transpose"
              type="number"
              min={-12}
              max={12}
              step={1}
              value={transpose}
              onChange={(e) => {
                const val = e.target.value;
                const n = parseInt(val, 10);
                const clamped = Number.isFinite(n) ? Math.max(-12, Math.min(12, n)) : 0;
                setTranspose(clamped);
              }}
              style={{ width: '70px', marginRight: '8px' }}
            />
            <span className="control-label">semitones</span>
          </div>
          <button type="button" className="reset-button" onClick={resetPositions}>
            Reset to C shape
          </button>
        </div>

        <section className="bulk-card">
          <div className="rows-header">
            <h2 style={{ margin: 0, color: '#23336e', fontSize: '1.2rem' }}>6-Input Rows</h2>
            <button type="button" className="small-button" onClick={addRow}>Add Row</button>
          </div>
          <div className="six-row-list">
            {rowResults.map((row, rIdx) => {
              const parsed = row.parsed;
              const isValid = !parsed.error && parsed.positions;
              const displayName = isValid && row.suggestions.length ? row.suggestions[0].displayName : 'â€”';
              return (
                <div key={row.id} className="six-input-row">
                  {row.cells.map((val, cIdx) => {
                    const err = parsed.errors && parsed.errors[cIdx];
                    const hasErr = !!err && err !== 'empty';
                    return (
                      <input
                        key={cIdx}
                        className={'cell-input' + (hasErr ? ' error' : '')}
                        value={val}
                        placeholder={cIdx === 0 ? 'X' : '0'}
                        onChange={(e) => updateCell(rIdx, cIdx, e.target.value)}
                        maxLength={3}
                        inputMode="text"
                      />
                    );
                  })}
                  <div className="row-meta">
                    <code className="shape-pill">{isValid ? formatShape(parsed.positions) : '{ ? ? ? ? ? ? }'}</code>
                    <span className="parsed-suggest">{displayName}</span>
                    <button
                      type="button"
                      className="small-button"
                      onClick={() => isValid && setPositions(parsed.positions)}
                      disabled={!isValid}
                      title="Load on fretboard"
                    >
                      Load
                    </button>
                    <button
                      type="button"
                      className="small-button"
                      onClick={() => removeRow(rIdx)}
                      disabled={rows.length <= 1}
                      title="Remove row"
                      style={{ background: '#9aa6ff' }}
                    >
                      Remove
                    </button>
                  </div>
                </div>
              );
            })}
          </div>
          <div className="bulk-hint">Type X for muted, 0 for open, and 1â€“24 for frets. Inputs are 3-chars wide so 11 1 doesnâ€™t look like 111.</div>
        </section>

        <Fretboard positions={positions} onChange={handleFretChange} tuning={tuning} />

        <section className="insight-card">
          <h2>Notes Played</h2>
          {analysis.playedNotes.length ? (
            <React.Fragment>
              <p>
                The voicing produces {analysis.uniqueNotes.length} unique note{analysis.uniqueNotes.length === 1 ? '' : 's'}.
                {analysis.bassNote ? ' Bass note: ' + analysis.bassNote + '.' : ''}
              </p>
              <div className="note-tags">
                {analysis.uniqueNotes.map((note) => (
                  <span key={note} className="note-tag">
                    {note}
                  </span>
                ))}
              </div>
              <ul className="note-breakdown">
                {analysis.playedNotes.map((note, index) => (
                  <li key={note.string + '-' + note.fret + '-' + index}>
                    <span className="note-strong">String {tuning.length - note.string}</span> fret {note.fret} â†’ <strong>{note.note}</strong>
                  </li>
                ))}
              </ul>
            </React.Fragment>
          ) : (
            <p>Select at least two strings to start the analysis.</p>
          )}
        </section>

        <section className="insight-card">
          <h2>Chord Suggestions</h2>
          {analysis.uniqueNotes.length < 2 ? (
            <p>You need at least two distinct notes to build a chord.</p>
          ) : chordSuggestions.length ? (
            <ul className="chord-list">
              {chordSuggestions.map((suggestion) => (
                <li key={suggestion.id} className="chord-item">
                  <span className="chord-name">{suggestion.displayName}</span>
                  <span className="chord-details">{suggestion.description}</span>
                  <span className="chord-formula">{suggestion.formula}</span>
                </li>
              ))}
            </ul>
          ) : (
            <p>We do not recognize this voicing yet. Try simplifying the shape or adjusting the bass note.</p>
          )}
        </section>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>
</body>
</html>
